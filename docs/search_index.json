[
["index.html", "Tidy time series forecasting with fable 1 Background", " Tidy time series forecasting with fable Mitchell O’Hara-Wild 2018-10-10 1 Background Collecting these principles in a book-like format is motivated by Max Kuhn’s Conventions for R Modeling Packages. The ideas presented in this resource are subject to revision, as the development of these tools are still experimental. This text aims to consolidate the information currently dispersed in the fable package documentation, wiki pages, issues, and emails in a way that is more accessible to the wider community. Hopefully this firstly helps us better design and plan the workflow of tidy forecasting, and invite external opinions to ensure that fable works well with the existing tidy modelling developments. "],
["tsibble.html", "2 Tidy time series 2.1 ts 2.2 tsibble", " 2 Tidy time series 2.1 ts Time series data structures in R vary substantially, however most time series models make use of the ts object structure from the stats package. This object concisely stores the time series index using three ‘time series parameters’ (tsp): start, frequency, and end. For most time series tools (such as arima, ets, stl) this structural information is sufficient, however it lacks details that are present in modern time series datasets: Multiple seasonality Irregular observations Exogenous information Many time series (that differ in length) In many senses this structure is limited, and inconsistent with the tidy data principles: Non-rectangular index structure Wide-format for keyed data (mts) Unnatural index format for importing data Difficulty working with tidyverse tools 2.2 tsibble The tsibble package by Earo Wang provides a tidy data structure for time series, and is well described in her introductory vignette. This data structure is sufficiently flexible to support the future of time series modelling tools (such as tbats, fasster and prophet). Beyond the data tidying and transformation tools that the package provides, the object also includes valuable structural information (index and key) for time series modelling. 2.2.1 index The index is essential for modelling as it can be used to identify the frequency and regularity of the observations. By storing a standard datetime object within the dataset, it makes irregular time series modelling possible. It also allows a more flexible specification of seasonal frequency (see seasonal period) that is easier to specify for the end user (a very common difficulty when constructing ts objects). 2.2.2 key Keys are used within tsibble to uniquely identify related time series in a tidy structure. They are also useful for identifying relational structures between each time series. This is especially useful for forecast reconciliation, where a hierarchical or grouped structure is imposed on a set of forecasts to impose relational constraints (typically aggregation). Keys within tsibble can be either nested (hierarchical) or crossed (grouped), and can be directly used to reconcile forecasts. This structure also has purpose for univariate models, as it allows batch forecasting to be applied across many time series. "],
["model.html", "3 Model basics 3.1 Model specification 3.2 Model formula 3.3 Selection parameters 3.4 Optimisation parameters 3.5 Computational parameters", " 3 Model basics The fablelite package provides a set of tools for creating models that work well together. These tools aim to simplify model development and encourage a consistent interface across many model types. By developing a model with fablelite, complexity introduced by batch forecasting and advanced functionality is handled automatically. This should allow model developers to focus on implementing model specific functionality. The model function is expected to accept a tsibble and model formula, and return a fitted model stored as a mable. 3.1 Model specification A consistent interface across models is essential. 3.2 Model formula 3.2.1 Transformations vignette(&quot;transformations&quot;, package=&quot;fable&quot;) 3.2.2 Specials 3.3 Selection parameters 3.4 Optimisation parameters 3.5 Computational parameters "],
["accessing-model-elements.html", "4 Accessing model elements 4.1 Display 4.2 Accessibility 4.3 Components", " 4 Accessing model elements 4.1 Display The print and summary methods are standard displays for fitted models. The print method typically displays a limited amount of key information, such as the model that was fit, and the estimated coefficients. The summary function extends the print method with a more detailed summary of fit, which may include measures for goodness of fit, and significance of model terms. As fable naturally supports batch/multiple forecasting, the print method is standardised for any number of models. A very short model specific display can be defined using the model_sum generic, which is shown in the mable. library(tsibbledata) UKLungDeaths %&gt;% ETS(mdeaths) ## # A mable: 1 model [1M] ## data model ## &lt;list&gt; &lt;model&gt; ## 1 &lt;tsibble [72 × 3]&gt; ETS(M,A,A) The summary method can then be used to reveal more information about this model, such as fitted parameters and goodness of fit. Ideally this information would also be standardised into a tabular form for batch modelling, although this is currently not the case. UKLungDeaths %&gt;% ETS(mdeaths) %&gt;% summary ## ETS(M,A,A) ## ## Smoothing parameters: ## alpha = 0.0002065548 ## beta = 0.0001865257 ## gamma = 0.000118306 ## ## Initial states: ## l b s1 s2 s3 s4 s5 ## 1671.676 -4.334248 373.1746 -121.3157 -246.1697 -484.8581 -476.2192 ## s6 s7 s8 s9 s10 s11 s12 ## -370.1939 -303.5806 -207.384 122.0022 483.3319 620.3601 610.8525 ## ## ## sigma: 0.0951 ## ## AIC AICc BIC ## 1033.474 1044.807 1072.177 4.2 Accessibility augment(), tidy(), glance() 4.3 Components In many cases, a model can be used to extract features or components from data in a similar way to decomposition methods. We use the components verb to extract a tsibble of data features that have been extracted via modelling or decomposition. State space models such as ETS are well suited to this functionality as the states often represent features of interest. UKLungDeaths %&gt;% ETS(mdeaths) %&gt;% components ## # A tsibble: 73 x 4 [1M] ## index level slope season ## &lt;mth&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1974 Jan 1672. -4.33 373. ## 2 1974 Feb 1667. -4.36 611. ## 3 1974 Mar 1663. -4.44 620. ## 4 1974 Apr 1658. -4.49 483. ## 5 1974 May 1654. -4.47 122. ## 6 1974 Jun 1649. -4.46 -207. ## 7 1974 Jul 1645. -4.48 -304. ## 8 1974 Aug 1640. -4.48 -370. ## 9 1974 Sep 1636. -4.48 -476. ## 10 1974 Oct 1632. -4.47 -485. ## # ... with 63 more rows It may also be worth storing how these components can be used to produce the response, which can be used for decomposition modelling. "],
["methods.html", "5 Model methods 5.1 Interpolation 5.2 Re-estimation 5.3 Simulation 5.4 Visualisation", " 5 Model methods 5.1 Interpolation Models that can be estimated in the presence of missing values can often be used to interpolate the unknown values. Often interpolated values can be taken from model’s fitted values, and some models may support more sophisticated interpolation methods. The forecast package provides the na.interp function for interpolating time series data, which uses linear interpolation for non-seasonal data, and STL decomposition for seasonal data. Tidy time series tools should allow users to interpolate missing values using any appropriate model. For example, the fpp2::mens400 dataset contains Olympic men’s 400m track final winning times. The winning times for the 1916, 1940 and 1944 Olympics are missing from the dataset. We could then interpolate these missing values using the fitted values from a linear model with a trend: as_tsibble(fpp2::mens400) %&gt;% LM(value ~ trend()) %&gt;% interpolate() ## # A tsibble: 31 x 2 [?] ## index value ## &lt;dttm&gt; &lt;dbl&gt; ## 1 1896-01-01 00:00:00 54.2 ## 2 1900-01-01 00:00:00 49.4 ## 3 1904-01-01 00:00:00 49.2 ## 4 1908-01-01 00:00:00 50 ## 5 1912-01-01 00:00:00 48.2 ## 6 1916-01-01 00:00:00 48.8 ## 7 1920-01-01 00:00:00 49.6 ## 8 1924-01-01 00:00:00 47.6 ## 9 1928-01-01 00:00:00 47.8 ## 10 1932-01-01 00:00:00 46.2 ## # ... with 21 more rows 5.2 Re-estimation https://github.com/tidyverts/fable/issues/43 5.2.1 refit() The refitting a model allows the same model to be applied to a new dataset. This is similar to the model argument available in most modelling functions from the forecast package. The refitted model should maintain the same structure and coefficients of the original model, with fitted information updated to reflect the model’s behaviour on the new dataset. It should also be possible to allow re-estimation of parameters using the reestimate argument, which keeps the selected model terms but updates the model coefficients/parameters. It is expected that a refit method uses a fitted model and replacement data to return a mable. For the ETS model for mdeaths estimated above: library(fable) ets_fit &lt;- as_tsibble(mdeaths) %&gt;% ETS(value) We may be interested in using the same model with the same coefficients to estimate the fdeaths series: refit(ets_fit, as_tsibble(fdeaths)) ## # A mable: 1 model [1M] ## data model ## &lt;list&gt; &lt;model&gt; ## 1 &lt;tsibble [72 × 2]&gt; ETS(M,A,A) 5.2.2 stream() Streaming data into a model allows a model to be extended to accomodate new, future data. Like refit, stream should allow re-estimation of the model parameters. As this can be a costly operation for some models, in most cases updating the parameters should not occur. However it is recommended that the model parameters are updated on a regular basis. Suppose we are estimating electricity demand data (tsibbledata::elecdemand), and after fitting a model to the existing data, a new set of data from the next month becomes available. ## Warning: replacing previous import &#39;fablelite::simulate&#39; by ## &#39;stats::simulate&#39; when loading &#39;fasster&#39; ## ## Attaching package: &#39;lubridate&#39; ## The following objects are masked from &#39;package:tsibble&#39;: ## ## interval, new_interval ## The following object is masked from &#39;package:base&#39;: ## ## date A (minimal) model for the electricity demand above can be estimated using fasster. fit &lt;- elec_tr %&gt;% fasster(Demand ~ WorkDay %S% (poly(1) + trig(10))) To extend these fitted values to include December’s electricity data, we can use the stream functionality: fit &lt;- fit %&gt;% stream(elec_stream) 5.3 Simulation Much like the tidymodels opinion toward predict, simulate should not default to an archived version of the training set. This allows models to be used for simulating new data sets, which is especially relevant for time series as often future paths beyond the training set are simulated. The simulate method for a fable model should accept these arguments (names chosen for consistency with tidymodels): object: The model itself new_data: The data used for simulation times: The number of simulated series (handled by fablelite) seed: Random generator initialisation (handled by fablelite) The new_data dataset extends existing stats::simulate functionality by allowing the simulation to accept a new time index for simulating beyond the sample (.idx), and allows the simulation to work with a new set of exogenous regressors (say x1 and x2). It is expected that the innovations (.innov) for the simulation are randomly generated for each repition number (rep), which can be achieved using the times argument. However, users should also be able to provide a set of pre-generated innovations (.innov) for each repition (.rep). If these columns are provided in the new_data, then this data will be passed directly to the simulation method (without generating new numbers over times replications). ## # A tsibble: 9 x 5 [1M] ## # Key: .rep [3] ## .rep .idx .innov x1 x2 ## &lt;int&gt; &lt;mth&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2017 Jan -1.72 0.0798 -1.97 ## 2 1 2017 Feb 1.61 2.72 -2.19 ## 3 1 2017 Mar -0.625 -0.713 -1.27 ## 4 2 2017 Jan -1.54 3.07 -2.37 ## 5 2 2017 Feb -0.986 3.44 -1.89 ## 6 2 2017 Mar 0.871 0.823 -1.37 ## 7 3 2017 Jan 0.488 7.71 -2.61 ## 8 3 2017 Feb 0.295 -0.392 -1.50 ## 9 3 2017 Mar -0.741 3.36 -2.69 For the end user, creating simulations would work like this: library(fable) library(tsibbledata) UKLungDeaths %&gt;% LM(mdeaths ~ fourier(&quot;year&quot;, K = 4) + fdeaths) %&gt;% simulate(UKLungDeaths, times = 5) ## # A tsibble: 360 x 3 [1M] ## # Key: .rep [5] ## index .rep .sim ## &lt;mth&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1974 Jan 1 2303. ## 2 1974 Feb 1 1762. ## 3 1974 Mar 1 2144. ## 4 1974 Apr 1 1744. ## 5 1974 May 1 1511. ## 6 1974 Jun 1 1191. ## 7 1974 Jul 1 1145. ## 8 1974 Aug 1 1223. ## 9 1974 Sep 1 941. ## 10 1974 Oct 1 1530. ## # ... with 350 more rows Or, if they wanted to simulate beyond the sample: library(lubridate) UKLungDeaths %&gt;% filter(year(index) &lt;= 1978) %&gt;% LM(mdeaths ~ fourier(&quot;year&quot;, K = 4) + fdeaths) %&gt;% simulate( UKLungDeaths %&gt;% filter(year(index) &gt; 1978), times = 5 ) ## # A tsibble: 60 x 3 [1M] ## # Key: .rep [5] ## index .rep .sim ## &lt;mth&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1979 Jan 1 2100. ## 2 1979 Feb 1 2009. ## 3 1979 Mar 1 1951. ## 4 1979 Apr 1 1747. ## 5 1979 May 1 1289. ## 6 1979 Jun 1 1322. ## 7 1979 Jul 1 1059. ## 8 1979 Aug 1 1082. ## 9 1979 Sep 1 1265. ## 10 1979 Oct 1 1029. ## # ... with 50 more rows 5.4 Visualisation Different plots are appropriate for visualising each type of model. For example, a plot of an ARIMA model may show the AR and/or MA roots from the model on a unit circle. A linear model has several common plots, including plots showing “Residuals vs Fitted” values, normality via a Q-Q plot, and measures of leverage. These model plots are further extended by the visreg package to show the affects of terms on the model’s response. Some models currently have no model-specific plots, such as ETS, which defaults to showing a components plot using the estimated states. Visualising these models poses a substantial challenge for consistency across models, and is made more difficult as batch modelling becomes commonplace. "],
["advanced.html", "6 Advanced modelling 6.1 Batch 6.2 Decomposition 6.3 Ensemble 6.4 Boosting 6.5 Reconciliation", " 6 Advanced modelling 6.1 Batch https://github.com/tidyverts/fable/wiki/Tidy-forecasting-with-the-fable-package Estimating multiple models is a key feature of fable. Most time series can be naturally disaggregated using a series of factors known as keys. These keys are used to uniquely identify separate time series, each of which can be modelled separately. UKLungDeaths %&gt;% gather(&quot;sex&quot;, &quot;deaths&quot;) %&gt;% ETS(deaths) ## # A mable: 2 models [1M] ## # Key: sex [2] ## sex data model ## &lt;chr&gt; &lt;list&gt; &lt;model&gt; ## 1 mdeaths &lt;tsibble [72 × 2]&gt; ETS(M,A,A) ## 2 fdeaths &lt;tsibble [72 × 2]&gt; ETS(M,N,M) 6.2 Decomposition https://github.com/tidyverts/fable/wiki/Combining-models Objects which support a components method can then have their components modelled separately. The working name for this functionality is model_components, however a shorter (single word) verb is preferred. The user should be able to specify how each of the components are modelled, and the components method should define how each component is combined (and perhaps some default models that can be used). library(tsibblestats) md_decomp &lt;- UKLungDeaths %&gt;% STL(mdeaths ~ season(window = 12)) %&gt;% components md_decomp ## # A tsibble: 72 x 4 [1M] ## index Trend Seasonal_year Remainder ## &lt;mth&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1974 Jan 1510. 594. 30.0 ## 2 1974 Feb 1523. 581. -241. ## 3 1974 Mar 1536. 469. -127. ## 4 1974 Apr 1549. 163. 165. ## 5 1974 May 1560. -193. 124. ## 6 1974 Jun 1571. -317. -5.09 ## 7 1974 Jul 1583. -366. 63.4 ## 8 1974 Aug 1593. -466. 3.69 ## 9 1974 Sep 1604. -476. 81.0 ## 10 1974 Oct 1615. -243. 120. ## # ... with 62 more rows md_decomp %&gt;% model_components(???) 6.3 Ensemble https://github.com/tidyverts/fable/issues/34 6.4 Boosting 6.5 Reconciliation https://github.com/tidyverts/fable/issues/36 "],
["forecast.html", "7 Forecasting 7.1 The fable object 7.2 Accessing forecasts 7.3 Bootstrapping 7.4 Visualisation", " 7 Forecasting 7.1 The fable object UKLungDeaths %&gt;% ETS(mdeaths) %&gt;% forecast() ## # A fable: 1 forecast [1M] ## data model new_data forecast ## &lt;list&gt; &lt;model&gt; &lt;list&gt; &lt;fc&gt; ## 1 &lt;tsibble [72 × 3]&gt; ETS(M,A,A) &lt;tsibble [24 × 1]&gt; ~N [h=24] Index Mean (backtransformed and bias adjusted) Standard error (may not be needed) Distribution 7.2 Accessing forecasts https://github.com/tidyverts/fasster/issues/38 7.3 Bootstrapping 7.4 Visualisation geom_forecast autoplot autolayer "],
["accuracy.html", "8 Forecast evaluation 8.1 Accuracy 8.2 Cross validation 8.3 Visualisation", " 8 Forecast evaluation Where possible, the accuracy evaluation should be handled by existing tidymodels tools such as yardstick. It is likely that some changes or extensions will be needed for full support of time series accuracy metrics. 8.1 Accuracy The forecast package implements accuracy as a function which is applied to a model. Out of sample accuracy can be computed by additionally providing a test set. It is probably more transparent to compute accuracy metrics by directly providing actual response values and model predictions. 8.2 Cross validation CV(tsbl, mdl, h, window_type, ...) 8.3 Visualisation "],
["report.html", "9 Reporting 9.1 Model equations 9.2 Object reports", " 9 Reporting 9.1 Model equations equation() displays a mathematical representation of the model that has been used. https://github.com/tidyverts/fable/issues/4 https://github.com/tidymodels/broom/issues/492 (currently not implemented) 9.2 Object reports report() returns a formatted summary of the object suitable for R Markdown documents and shiny applications. (currently not implemented) "]
]
