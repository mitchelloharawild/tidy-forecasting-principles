[
["methods.html", "5 Model methods 5.1 Display 5.2 Accessibility 5.3 Components 5.4 Interpolation 5.5 Re-estimation 5.6 Simulation 5.7 Visualisation", " 5 Model methods 5.1 Display print(), summary() 5.2 Accessibility augment(), tidy(), glance() 5.3 Components components() 5.4 Interpolation interpolate() 5.5 Re-estimation https://github.com/tidyverts/fable/issues/43 5.5.1 refit() https://github.com/tidyverts/fable/issues/43 5.5.2 stream() 5.6 Simulation Much like the tidymodels opinion toward predict, simulate should not default to an archived version of the training set. This allows models to be used for simulating new data sets, which is especially relevant for time series as often future paths beyond the training set are simulated. The simulate method for a fable model should accept these arguments (names chosen for consistency with tidymodels): object: The model itself new_data: The data used for simulation times: The number of simulated series seed: Random generator initialisation (handled by fablelite) The new_data dataset extends existing stats::simulate functionality by allowing the simulation to accept a new time index for simulating beyond the sample (.idx), and allows the simulation to work with a new set of exogenous regressors (say x1 and x2). It is expected that the innovations (.innov) for the simulation are randomly generated for each repition number (rep), which can be achieved using the times argument. However, users should also be able to provide a set of pre-generated innovations (.innov) for each repition (.rep). If these columns are provided in the new_data, then this data will be passed directly to the simulation method (without generating new numbers over times replications). ## # A tsibble: 9 x 5 [1M] ## # Key: .rep [3] ## .rep .idx .innov x1 x2 ## &lt;int&gt; &lt;mth&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2017 Jan -1.45 -0.362 -1.82 ## 2 1 2017 Feb -0.692 4.37 -1.91 ## 3 1 2017 Mar 2.13 4.23 -2.33 ## 4 2 2017 Jan 0.985 2.27 -0.273 ## 5 2 2017 Feb 0.760 5.56 -2.68 ## 6 2 2017 Mar -0.630 2.84 -1.52 ## 7 3 2017 Jan -0.186 0.542 -1.90 ## 8 3 2017 Feb 0.632 2.06 -2.05 ## 9 3 2017 Mar -0.909 4.93 -2.02 For the end user, creating simulations would work like this: library(fable) library(tsibbledata) UKLungDeaths %&gt;% LM(mdeaths ~ fourier(&quot;year&quot;, K = 4) + fdeaths) %&gt;% simulate(UKLungDeaths, times = 5) ## # A tsibble: 360 x 3 [1M] ## # Key: .rep [5] ## index .rep .sim ## &lt;mth&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1974 Jan 1 2323. ## 2 1974 Feb 1 1788. ## 3 1974 Mar 1 2116. ## 4 1974 Apr 1 1865. ## 5 1974 May 1 1457. ## 6 1974 Jun 1 1039. ## 7 1974 Jul 1 1172. ## 8 1974 Aug 1 974. ## 9 1974 Sep 1 1050. ## 10 1974 Oct 1 1556. ## # ... with 350 more rows Or, if they wanted to simulate beyond the sample: library(lubridate) UKLungDeaths %&gt;% filter(year(index) &lt;= 1978) %&gt;% LM(mdeaths ~ fourier(&quot;year&quot;, K = 4) + fdeaths) %&gt;% simulate( UKLungDeaths %&gt;% filter(year(index) &gt; 1978), times = 5 ) ## # A tsibble: 60 x 3 [1M] ## # Key: .rep [5] ## index .rep .sim ## &lt;mth&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1979 Jan 1 2138. ## 2 1979 Feb 1 2021. ## 3 1979 Mar 1 2150. ## 4 1979 Apr 1 1500. ## 5 1979 May 1 1369. ## 6 1979 Jun 1 1159. ## 7 1979 Jul 1 1051. ## 8 1979 Aug 1 1163. ## 9 1979 Sep 1 990. ## 10 1979 Oct 1 1220. ## # ... with 50 more rows 5.7 Visualisation "]
]
