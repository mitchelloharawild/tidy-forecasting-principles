# Model methods {#methods}

## Display
print(), summary()

## Accessibility

augment(), tidy(), glance()

## Components

components()

## Interpolation

interpolate()

## Re-estimation
https://github.com/tidyverts/fable/issues/43

### refit()
https://github.com/tidyverts/fable/issues/43

### stream()

## Simulation

Much like the `tidymodels` option toward `predict`, `simulate` should not default to an archived version of the training set. This allows models to be used for simulating new data sets, which is especially relevant for time series as often future paths beyond the training set are simulated.

The simulate method for a fable model should accept these arguments (names chosen for consistency with `tidymodels`):

* object: The model itself
* new_data: The data used for simulation
* times: The number of simulated series
* seed: Random generator initialisation

The `new_data` dataset extends existing `stats::simulate` functionality by allowing the simulation to accept a new time index for simulating beyond the sample (`.idx`), and allows the simulation to work with a new set of exogenous regressors (say `x1` and `x2`). 

It is expected that the innovations (`.innov`) for the simulation are randomly generated for each repition number (`rep`), which can be achieved using the `times` argument.  However, users should also be able to provide a set of pre-generated innovations (`.innov`) for each repition (`.rep`). If these columns are provided in the `new_data`, then this data will be passed directly to the simulation method (without generating new numbers over `times` replications).

```{r sim-newdata, echo=FALSE}
library(tsibble)
tsibble(
  .rep = rep(1:3, each = 3),
  .idx = rep(yearmonth("2017") + lubridate::month(0:2), 3),
  .innov = rnorm(9),
  x1 = rnorm(9, 2, 2), x2 = rnorm(9,-2), 
  index = .idx, key = id(.rep))
```

For the end user, creating simulations would work like this:

```{r sim-example, eval=FALSE}
library(fable)
library(tsibbledata)
UKLungDeaths %>% 
  LM(mdeaths ~ fourier("year", K = 4) + fdeaths) %>% 
  simulate(UKLungDeaths, times = 5)
```

Or, if they wanted to simulate beyond the sample:

```{r, eval = FALSE}
UKLungDeaths %>% 
  filter(year(index) <= 1978) %>% 
  LM(mdeaths ~ fourier("year", K = 4) + fdeaths) %>% 
  simulate(
    UKLungDeaths %>% filter(year(index) > 1978),
    times = 5
  )
```

## Visualisation
