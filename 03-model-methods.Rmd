# Model methods {#methods}

## Display
print(), summary()

## Accessibility

augment(), tidy(), glance()

## Components

components()

## Interpolation

interpolate()

## Re-estimation
https://github.com/tidyverts/fable/issues/43

### refit()
https://github.com/tidyverts/fable/issues/43

### stream()

## Simulation

Much like the [tidymodels opinion](https://tidymodels.github.io/model-implementation-principles/model-predictions.html#input-data) toward `predict`, `simulate` should not default to an archived version of the training set. This allows models to be used for simulating new data sets, which is especially relevant for time series as often future paths beyond the training set are simulated.

The simulate method for a fable model should accept these arguments (names chosen for consistency with `tidymodels`):

* object: The model itself
* new_data: The data used for simulation
* ~~times~~: The number of simulated series (handled by fablelite)
* ~~seed~~: Random generator initialisation (handled by fablelite)

The `new_data` dataset extends existing `stats::simulate` functionality by allowing the simulation to accept a new time index for simulating beyond the sample (`.idx`), and allows the simulation to work with a new set of exogenous regressors (say `x1` and `x2`). 

It is expected that the innovations (`.innov`) for the simulation are randomly generated for each repition number (`rep`), which can be achieved using the `times` argument.  However, users should also be able to provide a set of pre-generated innovations (`.innov`) for each repition (`.rep`). If these columns are provided in the `new_data`, then this data will be passed directly to the simulation method (without generating new numbers over `times` replications).

```{r sim-newdata, echo=FALSE}
library(tsibble)
tsibble(
  .rep = rep(1:3, each = 3),
  .idx = rep(yearmonth("2017") + lubridate::month(0:2), 3),
  .innov = rnorm(9),
  x1 = rnorm(9, 2, 2), x2 = rnorm(9,-2), 
  index = .idx, key = id(.rep))
```

For the end user, creating simulations would work like this:

```{r sim-example, eval = FALSE}
library(fable)
library(tsibbledata)
UKLungDeaths %>% 
  LM(mdeaths ~ fourier("year", K = 4) + fdeaths) %>% 
  simulate(UKLungDeaths, times = 5)
```

```{r sim-example-eval, echo = FALSE}
sim1 <- UKLungDeaths %>% 
  LM(mdeaths ~ fourier("year", K = 4) + fdeaths) %>% 
  simulate(UKLungDeaths, times = 5)
sim1
library(ggplot2)
ggplot(UKLungDeaths, aes(x = index, y = mdeaths)) + 
  geom_line(colour = "blue") + 
  geom_line(aes(y = .sim, group = .rep), data = sim1, alpha = 0.2) + 
  theme_minimal()
```


Or, if they wanted to simulate beyond the sample:

```{r sim-future, eval = FALSE}
library(lubridate)
UKLungDeaths %>% 
  filter(year(index) <= 1978) %>% 
  LM(mdeaths ~ fourier("year", K = 4) + fdeaths) %>% 
  simulate(
    UKLungDeaths %>% filter(year(index) > 1978),
    times = 5
  )
```
```{r sim-future-eval, echo=FALSE}
library(lubridate)
sim2 <- UKLungDeaths %>% 
  filter(year(index) <= 1978) %>% 
  LM(mdeaths ~ fourier("year", K = 4) + fdeaths) %>% 
  simulate(
    UKLungDeaths %>% filter(year(index) > 1978),
    times = 5
  )
sim2
library(ggplot2)
UKLungDeaths %>% 
  filter(year(index) <= 1978) %>% 
  ggplot(aes(x = index, y = mdeaths)) + 
  geom_line(colour = "blue") + 
  geom_line(aes(y = .sim, group = .rep), data = sim2, alpha = 0.2) + 
  theme_minimal()
```


## Visualisation
